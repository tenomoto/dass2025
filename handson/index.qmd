---
title: "随伴モデルを</br>作ってみよう"
author: "榎本剛"
format: revealjs
bibliography: ../refs.bib
csl: ../american-meteorological-society.csl
slide-number: true
footer: "データ同化夏の学校2025"
---

## Lotka-Volterraモデル

-   捕食・被食モデル
-   化学反応 [@Lotka:1920]や魚種交替 [@Volterra:1926]モデル
-   海洋生態系（NPZ）モデル [@Franks-etal:1986]
-   積雲対流の自己組織化のモデル [@Nober-Graf:2005]

## 支配方程式系

二元連立非線型常微分方程式系

$$
\begin{aligned}
\frac{\mathrm{d}x}{\mathrm{d}t} &= x(a_1 + a_2x + a_3y) \\
\frac{\mathrm{d}y}{\mathrm{d}t} &= y(a_4 + a_5y + a_6x)
\end{aligned}
$$

## 変数の定義

| 変数 | 定義 | 単位 | 標準値 |
|---|--------|----|:---:|
| $x,\,y$ | 密度 | 数$\,\mathrm{m}^{-2}$ | 計算 |
| $a_1,\,a_4$ | 比増加率 | $\mathrm{d}^{-1}$ | $4,-6$ |
| $a_2,\,a_5$ | 自己依存増加率 | $($数$\,\mathrm{m^{-2}})^{-1}\mathrm{d}^{-1}$ | $-2, 2$ |
| $a_3,\,a_6$ | 相手依存増加率 | $($数$\,\mathrm{m^{-2}})^{-1}\mathrm{d}^{-1}$ | $-4, 4$ |
| $x_1,\, y_1$ | 初期密度 | 数$\,\mathrm{m}^{-2}$ | $1, 1$ |

## 離散化

$$
\begin{aligned}
\frac{\mathrm{d}x}{\mathrm{d}t} &= x(a_1 + a_2x + a_3y) \\
\frac{\mathrm{d}y}{\mathrm{d}t} &= y(a_4 + a_5y + a_6x)
\end{aligned}
$$

::: {.panel-tabset}

### Fortran

```fortran
do n = 1, nmax-1
  x(n+1) = x(n) + dt * (x(n) * (a(1) + a(2) * x(n) + a(3) * y(n)))
  y(n+1) = y(n) + dt * (y(n) * (a(4) + a(5) * y(n) + a(6) * x(n)))
end do
```

### Python

```python
for i in range(nmax-1):
    x[n+1] = x[n] + dt * (x[n] * (a[0] + a[1] * x[n] + a[2] * y[n]))
    y[n+1] = y[n] + dt * (y[n] * (a[3] + a[4] * y[n] + a[5] * x[n]))
```

:::

## 時間発展

- 15日間の時間発展
- `dt = 0.001, nmax = 15001`

```{r}
#| fig-align: center

par(mar = c(5, 5, 1, 0))
dt <- 0.001
a <- c(4, -2, -4, -6, 2, 4)
x1 <- 1
y1 <- 1
nmax <- 15001

x <- rep(0, nmax)
y <- rep(0, nmax)
x[1] <- x1
y[1] <- y1
for (n in 1:(nmax-1)) {
  x[n+1] <- x[n] + dt * (x[n] * (a[1] + a[2] * x[n] + a[3] * y[n]))
  y[n+1] <- y[n] + dt * (y[n] * (a[4] + a[5] * y[n] + a[6] * x[n]))
}

plot(seq(0, 15, by = dt), x, type = "l", lwd = 2, col = "red",
     xlab = "Time (days)", ylab = "Density",
     cex.lab = 1.5, cex.axis = 1.5,
     xlim = c(0, 15), ylim = c(0, 2))
lines(seq(0, 15, by = dt), y, lwd = 2, col = "blue")
legend("topright", legend = c("Prey (x)", "Predator (y)"),
       col = c("red", "blue"), lwd = 2, cex = 1.5)
```

## 位相平面

```{r}
#| fig-asp: 1
#| fig-align: center

par(mar = c(5, 5, 0, 0))
plot(x, y, type = "l", lwd = 2,
     xlab = "Prey (x)", ylab = "Predator (y)",
     cex.lab = 2, cex.axis = 2,
     xlim = c(0, 2), ylim = c(0, 2), asp = 1)
x.nc <- seq(0, 2, length.out = 100)
points(x1, y1, pch = 4, lwd = 2, cex = 2)
lines(x.nc, -(a[1] + a[2] * x.nc) / a[3], lwd = 2, lty = 2, col = "red")
lines(x.nc, -(a[4] + a[6] * x.nc) / a[5], lwd = 2, lty = 2, col = "blue")
legend("topright", legend = c("x vs y","dx/dt = 0", "dy/dt = 0"),
       col = c("black","red", "blue"), lwd = 2, lty = c(1, 2, 2),
       cex = 2)
```

## おさらい

- 変分法データ同化では入力（初期値やパラメタ）を推定
- 出力（予測値）と観測との乖離（コスト函数）の最小化
- コスト函数の入力についての勾配を用いて最適化
- 随伴を求めてから離散化か、離散化してから随伴か。
- 直接勾配が計算できないので連鎖律を利用する。
- Lagrangeの未定乗数を用いる方法 [@Lawson-etal:1995]

## Lagrangeの未定乗数法

- モデル$F(X, Z, ...)$、制御変数 $X$、状態変数 $Z$
- 各ステップの未定乗数 $\lambda_n$ を随伴モデルから求める。
- $\lambda_n$ と $Z$ に関するモデルの微分の積の総和
- 各ステップでは以下を計算


$$
\lambda_X = \lambda_X + \lambda_Z\frac{\partial F}{\partial X}
$$

## 制御変数と状態変数、随伴変数

- 制御変数は $X \equiv (x_1,\,y_1,\,a_1,\,a_2,\,a_3,\,a_4,\,a_5,\,a_6)^\mathrm{T}$
- 状態変数は $Z \equiv (x, y)^\mathrm{T}$
- パラメタ数の長さ6の1次元配列 `a` 
- ステップ数の長さ`nmax`の1次元配列 `x`
- `a` の随伴変数は `a` をつけた長さ6の1次元配列 `aa`
- `x` と `y` の随伴変数は、それぞれ `ax` と `ay`

## 随伴モデル作成のルール

- 時間を逆行するので、コードを逆順に辿る。
- ループは逆に回す。
- 順行コードの右辺を制御変数 `a_6` で微分する。
- 微分に状態変数の随伴 `ay` を掛ける。
- これを制御変数の随伴 `a_6` に足す。
- 制御変数 `y` が複数回出てきたら、それぞれ微分する。
- 全ての制御変数について行う。
- 随伴変数は0に初期化する。

## 捕食者パラメタの随伴

$$
\frac{\mathrm{d}y}{\mathrm{d}t} = y(a_4 + a_5y + a_6x)
$$

::: {.panel-tabset}

### Fortran

```fortran
! y(n+1) = y(n) + dt * (y(n) * (a(4) + a(5) * y(n) + a(6) * x(n)))
aa(6) = aa(6) + dt * x(n) * y(n) * ay(n+1)
aa(5) = aa(5) + dt * y(n) * y(n) * ay(n+1)
aa(4) = aa(4) + dt * y(n) * ay(n+1)
```

### Python

```python
# y[n+1] = y[n] + dt * (y[n] * (a[3] + a[4] * y[n] + a[5] * x[n]))
aa[5] = aa[5] + dt * x[n] * y[n] * ay[n+1]
aa[4] = aa[4] + dt * y[n] * y[n] * ay[n+1]
aa[3] = aa[3] + dt * y[n] * ay[n+1]
```

:::

## 状態変数の随伴

$$
\frac{\mathrm{d}y}{\mathrm{d}t} = y(a_4 + a_5y + a_6x)
$$

::: {.panel-tabset}

### Fortran

```fortran
! y(n+1) = y(n) + dt * (y(n) * (a(4) + a(5) * y(n) + a(6) * x(n)))
ax(n) = ax(n) + dt * a(6) * y(n) * ay(n+1)
ay(n) = ay(n) + dt * a(5) * y(n) * ay(n+1)
ay(n) = ay(n) + (1 + dt * (a(4) + a(5) * y(n) + a(6) * x(n))) * ay(n+1)
```

### Python

```python
# y[n+1] = y[n] + dt * (y[n] * (a[3] + a[4] * y[n] + a[5] * x[n]))
ax[n] <- ax[n] + dt * a[5] * y[n] * ay[n+1]
ay[n] <- ay[n] + dt * a[4] * y[n] * ay[n+1]
ay[n] <- ay[n] + (1 + dt * (a[3] + a[4] * y[n] + a[5] * x[n])) * ay[n+1]
```

:::

## 被食者パラメタの随伴

$$
\frac{\mathrm{d}x}{\mathrm{d}t} = x(a_1 + a_2x + a_3y)
$$

::: {.panel-tabset}

### Fortran

```fortran
! x(n+1) = x(n) + dt * (x(n) * (a(1) + a(2) * x(n) + a(3) * y(n)))
aa(3) = aa(3) + dt * y(n) * x(n) * ax(n+1)
aa(2) = aa(2) + dt * x(n) * x(n) * ax(n+1)
aa(1) = aa(1) + dt * x(n) * ax(n+1)
```

### Python

```python
# x[n+1] = x[n] + dt * (x[n] * (a[0] + a[1] * x[n] + a[2] * y[n]))
aa[2] = aa[2] + dt * y[n] * x[n] * ax[n+1]
aa[1] = aa[1] + dt * x[n] * x[n] * ax[n+1]
aa[0] = aa[0] + dt * x[n] * ax[n+1]
```
:::

## 状態変数の随伴

$$
\frac{\mathrm{d}x}{\mathrm{d}t} = x(a_1 + a_2x + a_3y)
$$

::: {.panel-tabset}

### Fortran

```fortran
! x(n+1) = x(n) + dt * (x(n) * (a(1) + a(2) * x(n) + a(3) * y(n)))
ay(n) = ay(n) + dt * a(3) * x(n) * ax(n+1)
ax(n) = ax(n) + dt * a(2) * x(n) * ax(n+1)
ax(n) = ax(n) + (1 + dt * (a(1) + a(2) * x(n) + a(3) * y(n))) * ax(n+1)
```

### Python

```python
# x[n+1] = x[n] + dt * (x[n] * (a[0] + a[1] * x[n] + a[2] * y[n]))
ay[n] = ay[n] + dt * a[2] * x[n] * ax[n+1]
ax[n] = ax[n] + dt * a[1] * x[n] * ax[n+1]
ax[n] = ax[n] + (1 + dt * (a[0] + a[1] * x[n] + a[2] * y[n])) * ax[n+1]
```

:::


## 随伴モデル

::: {.panel-tabset}

### Fortran

```fortran
aa(:) = 0d0
ax(:) = 0d0
ay(:) = 0d0
do nmax-1, 1, -1
  aa(6) = aa(6) + dt * x(n) * y(n) * ay(n+1)
  aa(5) = aa(5) + dt * y(n) * y(n) * ay(n+1)
  aa(4) = aa(4) + dt * y(n) * ay(n+1)
  ax(n) = ax(n) + dt * a(6) * y(n) * ay(n+1)
  ay(n) = ay(n) + dt * a(5) * y(n) * ay(n+1)
  ay(n) = ay(n) + (1 + dt * (a(4) + a(5) * y(n) + a(6) * x(n))) * ay(n+1)
  aa(3) = aa(3) + dt * y(n) * x(n) * ax(n+1)
  aa(2) = aa(2) + dt * x(n) * x(n) * ax(n+1)
  aa(1) = aa(1) + dt * x(n) * ax(n+1)
  ay(n) = ay(n) + dt * a(3) * x(n) * ax(n+1)
  ax(n) = ax(n) + dt * a(2) * x(n) * ax(n+1)
  ax(n) = ax(n) + (1 + dt * (a(1) + a(2) * x(n) + a(3) * y(n))) * ax(n+1)
end do
```

### Python

```python
aa = np.zeros(6)
ax = np.zeros(nmax)
ay = np.zeros(nmax)
for i in reversed(range(nmax-1)):
    aa[5] = aa[5] + dt * x[n] * y[n] * ay[n+1]
    aa[4] = aa[4] + dt * y[n] * y[n] * ay[n+1]
    aa[3] = aa[3] + dt * y[n] * ay[n+1]
    ax[n] = ax[n] + dt * a[5] * y[n] * ay[n+1]
    ay[n] = ay[n] + dt * a[4] * y[n] * ay[n+1]
    ay[n] = ay[n] + (1 + dt * (a[3] + a[4] * y[n] + a[5] * x[n])) * ay[n+1]
    aa[2] = aa[2] + dt * y[n] * x[n] * ax[n+1]
    aa[1] = aa[1] + dt * x[n] * x[n] * ax[n+1]
    aa[0] = aa[0] + dt * x[n] * ax[n+1]
    ay[n] = ay[n] + dt * a[2] * x[n] * ax[n+1]
    ax[n] = ax[n] + dt * a[1] * x[n] * ax[n+1]
    ax[n] = ax[n] + (1 + dt * (a[0] + a[1] * x[n] + a[2] * y[n])) * ax[n+1]
```

:::

## 数値最適化

- 得られた `aa` や `ax`、`ay`はコスト函数の初期勾配
- 最急降下法
$$
X^{(i+1)} = X^{(i)} - \alpha\nabla_{X(0)}J
$$
- 勾配を用いる共軛勾配法や準ニュートン法
- [scipy.optimize](https://docs.scipy.org/doc/scipy/reference/optimize.html)
- Nocedal [L-BFGS](http://users.iems.northwestern.edu/~nocedal/lbfgs.html) [CG+](http://users.iems.northwestern.edu/~nocedal/CG+.html)
- [NLopt](https://nlopt.readthedocs.io/)

## 課題

- 捕食・被食モデルの時間発展（スライド6）を調べる。
    - 初期状態やパラメタを変えてみよう。
    - 位相空間にプロットする（スライド7）。
- 随伴モデルを作成する。
    - 異なる初期値とから真の初期値を復元する。
    - 異なる初期値とパラメタから真値を復元する。
    - 最適化手法を変えてみる。
    - 背景誤差や観測誤差を考慮する。

## 参考文献

::: refs
:::
